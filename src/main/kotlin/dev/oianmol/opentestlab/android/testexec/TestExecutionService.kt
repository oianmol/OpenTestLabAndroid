package dev.oianmol.dev.oianmol.opentestlab.android.testexec

import dev.oianmol.opentestlab.*
import dev.oianmol.opentestlab.android.testexec.TestExecScope
import dev.oianmol.opentestlab.android.testexec.testrunner.ITestRunner
import io.grpc.Status
import io.grpc.StatusException
import kotlinx.coroutines.*
import kotlinx.coroutines.flow.Flow
import kotlinx.coroutines.flow.flow
import kotlinx.coroutines.flow.flowOn
import java.util.logging.Logger
import kotlin.time.Duration.Companion.minutes
import kotlin.time.Duration.Companion.seconds

class TestExecutionService(
    private val testExecScope: TestExecScope,
    private val testRunner: ITestRunner,
    dispatcher: CoroutineDispatcher = Dispatchers.IO
) : TestExecutionServiceGrpcKt.TestExecutionServiceCoroutineImplBase(dispatcher) {
    private val logger = Logger.getLogger("TestExecutionService")

    override suspend fun executeTests(request: DeviceFarmTestSpec): DeviceFarmTestResults {
        val taskExecSpec = testExecScope.prepareFor(request)

        if (testRunner.canExecute(taskExecSpec)) {
            return testRunner.execute(taskExecSpec)
        } else {
            println("we will now continue to retry for 10 minutes with 10 sec delay")
            runCatching { // we eat up cancellation exception here by not calling runCatchingCancellable
                withTimeout(10.minutes) { // keep trying for 10 minutes
                    while (this.isActive) {
                        delay(10.seconds)
                        println("Retrying to check available device")
                        if (testRunner.canExecute(taskExecSpec)) {
                            break
                        }
                    }
                }
            }
            val canExecute = testRunner.canExecute(taskExecSpec)
            println("can execute after 10 minutes $canExecute ?")
            if (canExecute.not()) {
                println("Caused ${Status.RESOURCE_EXHAUSTED}")
                throw StatusException(Status.RESOURCE_EXHAUSTED)
            } else {
                return testRunner.execute(taskExecSpec)
            }
        }
    }

    override fun uploadTestApk(requests: Flow<TestApkUpload>): Flow<StreamLogs> = flow {
        var dirCreated = false
        requests.collect { testApkUpload ->
            if (dirCreated.not()) {
                testExecScope.createDirs(testApkUpload.ciUniqueBuildNumber)
                emit(
                    StreamLogs.newBuilder()
                        .setMessage("Test Directory created for ${testApkUpload.ciUniqueBuildNumber}").build()
                )
                dirCreated = true
            }
            if (testApkUpload.testApk.isEmpty) {
                currentCoroutineContext().cancel()
            } else {
                testExecScope.writeFiles(testApkUpload) {
                    emit(StreamLogs.newBuilder().setMessage("Writing file ${testApkUpload.fileType.name}").build())
                }
            }
        }
    }.flowOn(Dispatchers.IO)
}