package dev.oianmol.dev.oianmol.opentestlab.android.devicefarm.cli

import java.util.logging.Level
import java.util.logging.Logger

object CommandLine {
    private val logger = Logger.getLogger("deviceConnection")

    private val defaultShell: String by lazy {
        if (System.getProperty("os.name").lowercase().contains("win")) {
            System.getenv("COMSPEC") ?: "cmd.exe"
        } else {
            System.getenv("SHELL") ?: "/bin/sh"
        }
    }

    private val shellOptions: List<String> by lazy {
        if (System.getProperty("os.name").lowercase().contains("win")) {
            listOf("/c")
        } else {
            listOf("-l", "-c")
        }
    }

    fun executeCommand(command: String?): Result<String> {
        if (command.isNullOrBlank()) {
            logger.warning("Command is null or blank")
            return Result.failure(IllegalArgumentException("Command cannot be null or blank"))
        }

        println("Executing: $command")
        return runCatching {
            val pb = ProcessBuilder(defaultShell, *shellOptions.toTypedArray(), command)
            val process = pb.start()
            val output = StringBuilder()
            val errorOutput = StringBuilder()

            process.inputStream.bufferedReader().use { it.forEachLine { line -> output.appendLine(line) } }
            process.errorStream.bufferedReader().use { it.forEachLine { line -> errorOutput.appendLine(line) } }

            val exitCode = process.waitFor()
            if (exitCode != 0) {
                val errorMsg = "Command execution failed with exit code $exitCode: ${errorOutput.toString()}"
                logger.severe(errorMsg)
                throw RuntimeException(errorMsg)
            }

            val result = output.toString()
            println(result)
            result
        }.onFailure {
            logger.log(Level.SEVERE, "Command execution failed", it)
        }
    }
}
