package dev.oianmol.opentestlab.tasks

import com.android.build.gradle.api.BaseVariantOutput
import com.google.protobuf.ByteString
import dev.oianmol.opentestlab.*
import io.grpc.ManagedChannel
import io.grpc.ManagedChannelBuilder
import kotlinx.coroutines.*
import kotlinx.coroutines.flow.FlowCollector
import kotlinx.coroutines.flow.flow
import kotlinx.coroutines.flow.flowOn
import org.gradle.api.DefaultTask
import org.gradle.api.DomainObjectCollection
import org.gradle.api.GradleException
import org.gradle.api.Project
import org.gradle.api.tasks.Input
import org.gradle.api.tasks.TaskAction
import java.io.File
import java.util.concurrent.TimeUnit.SECONDS

abstract class AndroidTestDeviceFarmTask : DefaultTask() {

    @Input
    var appBinary: String? = null

    @Input
    var applicationPackageName: String? = null
    @Input
    var applicationTestPackageName: String? = null

    @Input
    var testAppBinary: String? = null

    @TaskAction
    fun connectDevices() {
        requireNotNull(appBinary) {
            "APK/AAB was not built for executing test cases! please assemble first"
        }

        requireNotNull(testAppBinary) {
            "AndroidTest APK/AAB was not built for executing test cases! please assemble first"
        }

        logger.lifecycle("appBinary ${appBinary} testAppBinary${testAppBinary}")
        runBlocking {
            val channel = managedChannel()
            runCatchingCancellable {
                val apk = File(appBinary)
                val testApk = File(testAppBinary)
                with(DeviceFarmServiceGrpcKt.DeviceFarmServiceCoroutineStub(channel)) {
                    deviceFarmInfo(this).availableDevices()?.let {
                        dumpDebugLog("Executing Tests for Test APK ${testApk.absolutePath}")
                        val build = buildIdentifier(project)

                        with(TestExecutionServiceGrpcKt.TestExecutionServiceCoroutineStub(channel)) {
                            uploadApks(this, testApk, build, apk)

                            executeTests(this, build)
                        }

                        val directory = fileForTestResults(project)

                        with(ReportManagementServiceGrpcKt.ReportManagementServiceCoroutineStub(channel)) {
                            pullReportsFromDeviceFarm(this, build, directory, project)
                        }

                        withResult(directory.listFiles())

                        close(channel)
                    } ?: run {
                        close(channel)
                        throw GradleException(
                            "We do not have any available devices to test this ðŸ¤•",
                        )
                    }
                }
            }.exceptionOrNull()?.let {
                closeAndExit(channel, it)
            }
        }
    }

    private fun closeAndExit(channel: ManagedChannel, it: Throwable) {
        close(channel)
        if (it is GradleException) {
            dumpDebugLog(it.stackTraceToString())
            throw it
        } else {
            throw it
        }
    }

    private suspend fun executeTests(
        client: TestExecutionServiceGrpcKt.TestExecutionServiceCoroutineStub,
        build: String,
    ) {
        client.executeTests(
            DeviceFarmTestSpec.newBuilder()
                .setCiUniqueBuildNumber(build)
                .setListenerClass("dev.oianmol.sampleandroidapp.runner.OpenAndroidTestRunListener")
                .setInstrumentPackage(applicationPackageName)
                .setPackageName(applicationPackageName)
                .setTestPackageName(applicationTestPackageName)
                .setCustomRunner("androidx.test.runner.AndroidJUnitRunner")
                .build(),
        )
    }

    private suspend fun uploadApks(
        client: TestExecutionServiceGrpcKt.TestExecutionServiceCoroutineStub,
        testApk: File,
        build: String,
        apk: File,
    ) {
        val uploadJob = runCatching {
            client.uploadTestApk(
                flow {
                    uploadAndroidApk(this, FileType.TestApk, testApk, build)
                    uploadAndroidApk(this, FileType.AndroidApk, apk, build)
                    currentCoroutineContext().cancel()
                },
            ).flowOn(Dispatchers.IO).collect {
                dumpDebugLog(it.toString())
            }
        }
        dumpDebugLog(uploadJob.toString())
    }

    private suspend fun uploadAndroidApk(
        flowCollector: FlowCollector<TestApkUpload>,
        androidApk: FileType,
        testApk: File,
        build: String,
    ) {
        var totalSize = testApk.length()
        val stream = testApk.inputStream()
        stream.use { fileInputStream ->
            while (totalSize != 0L) {
                val bytes = ByteArray(Math.min(4086L, totalSize).toInt()) //
                // we read either 4086 or less bytes pending to read from stream
                val read = withContext(Dispatchers.IO) {
                    fileInputStream.read(bytes)
                }
                // we reduce the read amount from total size
                totalSize -= read
                flowCollector.emit(
                    TestApkUpload.newBuilder()
                        .setCiUniqueBuildNumber(build)
                        .setFileType(androidApk)
                        .setTestApk(ByteString.copyFrom(bytes))
                        .build(),
                )
            }
        }
    }

    private fun close(channel: ManagedChannel) {
        channel.shutdown().awaitTermination(5L, SECONDS)
    }

    private fun DeviceFarmInfo.availableDevices(): MutableList<DeviceFarmDevice>? {
        return this.machinesList.firstOrNull()?.devicesList?.takeIf { it.isNotEmpty() }
    }

    private fun dumpDebugLog(message: String) {
        project.logger.lifecycle(message)
    }

    private fun withResult(testResultFiles: Array<File>?) {
        dumpDebugLog("We will store the test results so that we upload them to CircleCI artifacts.")
        testResultFiles?.filter { it.isFile && it.extension == "xml" }?.takeIf { it.isNotEmpty() }
            ?.let {
                val content = it.map {
                    it.readText()
                }
                val hasFailures = content.filter {
                    it.contains("<failure")
                }
                if (hasFailures.isNotEmpty()) {
                    dumpDebugLog(hasFailures.joinToString("\n"))
                    throw GradleException(
                        "Oops we have failing tests \uD83D\uDE2D \n",
                    )
                } else {
                    dumpDebugLog("All Tests pass! ðŸ¦¾")
                }
            } ?: run {
            throw GradleException("No test result files available!")
        }
    }

    private suspend fun deviceFarmInfo(client: DeviceFarmServiceGrpcKt.DeviceFarmServiceCoroutineStub): DeviceFarmInfo {
        val deviceFarm = client.getDeviceFarm(Empty.getDefaultInstance())

        dumpDebugLog("Connecting to the devices on device farm")
        deviceFarm.machinesList.forEachIndexed { index, machine ->
            dumpDebugLog("Machine ${index.plus(1)}...$machine")
        }
        return deviceFarm
    }
}

suspend fun pullReportsFromDeviceFarm(
    client: ReportManagementServiceGrpcKt.ReportManagementServiceCoroutineStub,
    build: String,
    directory: File,
    project: Project,
) {
    runCatching {
        client.pullReportFiles(
            ReportsRequest.newBuilder()
                .setCiUniqueBuildNumber(build)
                .build(),
        ).flowOn(Dispatchers.IO).collect { reportFiles ->
            File(directory, reportFiles.fileName)
                .also {
                    it.appendBytes(reportFiles.reportFile.toByteArray())
                }
        }
    }
}

fun managedChannel(): ManagedChannel = ManagedChannelBuilder.forTarget(
    System.getenv("ORG_GRADLE_PROJECT_DEVICE_FARM_URL")
        .takeIf { !it.isNullOrEmpty() } ?: "localhost:8081",
)
    .usePlaintext()
    .maxInboundMessageSize(Int.MAX_VALUE)
    .maxInboundMetadataSize(Int.MAX_VALUE)
    .build()

fun fileForTestResults(project: Project): File {
    val userHome = File(System.getProperty("user.home"))
    val testResultsDir = File(userHome, "test-results")
    val directory = File(testResultsDir, "androidTestResults")
    project.logger.debug("Saving report to ${directory.absolutePath}")
    directory.deleteRecursively()
    directory.mkdirs()
    return directory
}

fun buildIdentifier(project: Project) =
    "${project.getCurrentGitBranchName()}${System.getenv("CIRCLE_BUILD_NUM") ?: "${System.currentTimeMillis()}"}"

private fun Project.testApks(): Pair<File, File> {
    val testApkFileDir =
        File(projectDir.parentFile, "app/build/outputs/apk/androidTest/debug")
    val apkDir = File(projectDir.parentFile, "app/build/outputs/apk/debug")

    val testApk =
        testApkFileDir.listFiles()?.firstOrNull { it.isFile && it.extension == "apk" }
    val apk = apkDir.listFiles()?.first { it.isFile && it.extension == "apk" }
    require(testApk != null)
    require(apk != null)
    return Pair(testApk, apk)
}
